//+------------------------------------------------------------------+
//|                                           OrderReopenTests.mq5   |
//|                        Sugamara - Order Reopen Unit Tests        |
//|                                                                  |
//|  Unit tests per verificare il corretto funzionamento del         |
//|  sistema di riapertura ciclica degli ordini                      |
//+------------------------------------------------------------------+
#property copyright "Sugamara (C) 2025"
#property link      "https://sugamara.com"
#property version   "1.00"
#property script_show_inputs

//+------------------------------------------------------------------+
//| Include necessari                                                |
//+------------------------------------------------------------------+
#include "../Config/Enums.mqh"
#include "../Config/InputParameters.mqh"
#include "../Core/GlobalVariables.mqh"
#include "../Utils/Helpers.mqh"
#include "../Utils/GridHelpers.mqh"

//+------------------------------------------------------------------+
//| TEST FRAMEWORK - Struttura base per i test                       |
//+------------------------------------------------------------------+
struct TestResult {
    string testName;
    bool passed;
    string message;
    datetime executionTime;
};

TestResult g_testResults[];
int g_totalTests = 0;
int g_passedTests = 0;
int g_failedTests = 0;

// Saved input parameters for restoration
bool saved_EnableCyclicReopen;
int saved_MaxCyclesPerLevel;
double saved_ReopenOffset_Pips_STOP_ORDERS;
bool saved_PauseReopenOnExtreme;
ENUM_ATR_CONDITION saved_currentATR_Condition;

//+------------------------------------------------------------------+
//| Assert Functions                                                 |
//+------------------------------------------------------------------+
bool AssertTrue(string testName, bool condition, string errorMsg = "") {
    ArrayResize(g_testResults, g_totalTests + 1);
    g_testResults[g_totalTests].testName = testName;
    g_testResults[g_totalTests].passed = condition;
    g_testResults[g_totalTests].message = condition ? "PASS" : ("FAIL: " + errorMsg);
    g_testResults[g_totalTests].executionTime = TimeCurrent();

    g_totalTests++;
    if(condition) {
        g_passedTests++;
        Print("[✓] ", testName, " - PASSED");
    } else {
        g_failedTests++;
        Print("[✗] ", testName, " - FAILED: ", errorMsg);
    }

    return condition;
}

bool AssertFalse(string testName, bool condition, string errorMsg = "") {
    return AssertTrue(testName, !condition, errorMsg);
}

bool AssertEquals(string testName, double actual, double expected, double tolerance = 0.00001, string context = "") {
    bool passed = MathAbs(actual - expected) <= tolerance;
    string msg = passed ? "PASS" :
        StringFormat("Expected %.5f, got %.5f (tolerance %.5f) %s",
                     expected, actual, tolerance, context);
    return AssertTrue(testName, passed, msg);
}

bool AssertEqualsInt(string testName, int actual, int expected, string context = "") {
    bool passed = (actual == expected);
    string msg = passed ? "PASS" :
        StringFormat("Expected %d, got %d %s", expected, actual, context);
    return AssertTrue(testName, passed, msg);
}

//+------------------------------------------------------------------+
//| Test Suite Header                                                |
//+------------------------------------------------------------------+
void PrintTestHeader(string suiteName) {
    Print("═══════════════════════════════════════════════════════════════");
    Print("  ", suiteName);
    Print("═══════════════════════════════════════════════════════════════");
}

void PrintTestSummary() {
    Print("");
    Print("═══════════════════════════════════════════════════════════════");
    Print("  TEST SUMMARY");
    Print("═══════════════════════════════════════════════════════════════");
    Print("Total Tests:  ", g_totalTests);
    Print("Passed:       ", g_passedTests, " (", (g_totalTests > 0 ? (g_passedTests*100.0/g_totalTests) : 0), "%)");
    Print("Failed:       ", g_failedTests);
    Print("═══════════════════════════════════════════════════════════════");

    if(g_failedTests == 0) {
        Print("✓ ALL TESTS PASSED!");
    } else {
        Print("✗ SOME TESTS FAILED - Review output above");
    }
}

//+------------------------------------------------------------------+
//| SETUP - Inizializzazione environment test                        |
//+------------------------------------------------------------------+
void SetupTestEnvironment() {
    // Inizializza variabili globali necessarie
    _Symbol = Symbol();
    symbolDigits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
    symbolPoint = SymbolInfoDouble(_Symbol, SYMBOL_POINT);

    // Imposta parametri di default per i test
    GridLevelsPerSide = 10;
    BaseLot = 0.01;

    // Initialize arrays
    InitializeArrays();

    Print("Test environment initialized:");
    Print("  Symbol: ", _Symbol);
    Print("  Digits: ", symbolDigits);
    Print("  Point: ", symbolPoint);
}

//+------------------------------------------------------------------+
//| Save/Restore Input Parameters                                    |
//+------------------------------------------------------------------+
void SaveInputParameters() {
    saved_EnableCyclicReopen = EnableCyclicReopen;
    saved_MaxCyclesPerLevel = MaxCyclesPerLevel;
    saved_ReopenOffset_Pips_STOP_ORDERS = ReopenOffset_Pips_STOP_ORDERS;
    saved_PauseReopenOnExtreme = PauseReopenOnExtreme;
    saved_currentATR_Condition = currentATR_Condition;
}

void RestoreInputParameters() {
    EnableCyclicReopen = saved_EnableCyclicReopen;
    MaxCyclesPerLevel = saved_MaxCyclesPerLevel;
    ReopenOffset_Pips_STOP_ORDERS = saved_ReopenOffset_Pips_STOP_ORDERS;
    PauseReopenOnExtreme = saved_PauseReopenOnExtreme;
    currentATR_Condition = saved_currentATR_Condition;
}

//+------------------------------------------------------------------+
//| Reset Grid Status Arrays for Clean Tests                         |
//+------------------------------------------------------------------+
void ResetGridStatusForTests() {
    for(int i = 0; i < MAX_GRID_LEVELS; i++) {
        gridA_Upper_Status[i] = ORDER_NONE;
        gridA_Lower_Status[i] = ORDER_NONE;
        gridB_Upper_Status[i] = ORDER_NONE;
        gridB_Lower_Status[i] = ORDER_NONE;

        gridA_Upper_Cycles[i] = 0;
        gridA_Lower_Cycles[i] = 0;
        gridB_Upper_Cycles[i] = 0;
        gridB_Lower_Cycles[i] = 0;

        gridA_Upper_LastClose[i] = 0;
        gridA_Lower_LastClose[i] = 0;
        gridB_Upper_LastClose[i] = 0;
        gridB_Lower_LastClose[i] = 0;

        gridA_Upper_EntryPrices[i] = 0;
        gridA_Lower_EntryPrices[i] = 0;
        gridB_Upper_EntryPrices[i] = 0;
        gridB_Lower_EntryPrices[i] = 0;
    }
}

//+------------------------------------------------------------------+
//| TESTABLE VERSION: IsPriceAtReopenLevelSmart                      |
//| Accepts currentPrice as parameter for unit testing               |
//+------------------------------------------------------------------+
bool IsPriceAtReopenLevelSmart_Testable(double levelPrice, ENUM_ORDER_TYPE orderType, double currentPrice) {
    // LIMIT orders: sempre immediato (broker rifiuta se prezzo non valido)
    if(orderType == ORDER_TYPE_BUY_LIMIT || orderType == ORDER_TYPE_SELL_LIMIT) {
        return true;
    }

    if(currentPrice <= 0) return false;

    double offsetPoints = PipsToPoints(ReopenOffset_Pips_STOP_ORDERS);
    bool canReopen = false;

    switch(orderType) {
        case ORDER_TYPE_BUY_STOP:
            // BUY STOP: piazza quando prezzo SOTTO entry - garantisce validità
            {
                double targetPrice = levelPrice - offsetPoints;
                canReopen = (currentPrice <= targetPrice);
            }
            break;

        case ORDER_TYPE_SELL_STOP:
            // SELL STOP: piazza quando prezzo SOPRA entry - garantisce validità
            {
                double targetPrice = levelPrice + offsetPoints;
                canReopen = (currentPrice >= targetPrice);
            }
            break;

        default:
            return true;
    }

    return canReopen;
}

//+------------------------------------------------------------------+
//| TEST SUITE 12: IsPriceAtReopenLevelSmart                         |
//| Tests the smart reopen logic for different order types           |
//+------------------------------------------------------------------+
void Test_IsPriceAtReopenLevelSmart() {
    PrintTestHeader("TEST SUITE 12: IsPriceAtReopenLevelSmart");

    SaveInputParameters();

    double entryPrice = 1.10000;
    ReopenOffset_Pips_STOP_ORDERS = 3.0; // 3 pips offset = 30 points (5 digits)
    double offsetPoints = PipsToPoints(3.0);

    Print("\n--- Test Setup ---");
    Print("  Entry Price: ", entryPrice);
    Print("  Offset: ", ReopenOffset_Pips_STOP_ORDERS, " pips = ", offsetPoints, " points");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 12.1-12.2: LIMIT orders sempre TRUE (intrinsecamente protetti)
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing LIMIT Orders (always immediate) ---");

    // 12.1: BUY_LIMIT @ qualsiasi prezzo = TRUE
    bool result = IsPriceAtReopenLevelSmart_Testable(entryPrice, ORDER_TYPE_BUY_LIMIT, 1.09500);
    AssertTrue("12.1 BUY_LIMIT.AnyPrice.Below", result,
               "BUY_LIMIT should always return TRUE (price below)");

    result = IsPriceAtReopenLevelSmart_Testable(entryPrice, ORDER_TYPE_BUY_LIMIT, 1.10500);
    AssertTrue("12.1b BUY_LIMIT.AnyPrice.Above", result,
               "BUY_LIMIT should always return TRUE (price above)");

    // 12.2: SELL_LIMIT @ qualsiasi prezzo = TRUE
    result = IsPriceAtReopenLevelSmart_Testable(entryPrice, ORDER_TYPE_SELL_LIMIT, 1.09500);
    AssertTrue("12.2 SELL_LIMIT.AnyPrice.Below", result,
               "SELL_LIMIT should always return TRUE (price below)");

    result = IsPriceAtReopenLevelSmart_Testable(entryPrice, ORDER_TYPE_SELL_LIMIT, 1.10500);
    AssertTrue("12.2b SELL_LIMIT.AnyPrice.Above", result,
               "SELL_LIMIT should always return TRUE (price above)");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 12.3-12.5: BUY_STOP logic (price must be BELOW entry-offset)
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing BUY_STOP Orders ---");

    // BUY_STOP @ 1.10000 with offset 3 pips:
    // Target price = 1.10000 - 0.00030 = 1.09970
    // Should reopen when price <= 1.09970

    // 12.3: Price well below threshold = TRUE
    double testPrice = 1.09950; // Below 1.09970
    result = IsPriceAtReopenLevelSmart_Testable(entryPrice, ORDER_TYPE_BUY_STOP, testPrice);
    AssertTrue("12.3 BUY_STOP.BelowThreshold", result,
               StringFormat("BUY_STOP @ %.5f: price %.5f should be TRUE (below threshold %.5f)",
                           entryPrice, testPrice, entryPrice - offsetPoints));

    // 12.4: Price above entry = FALSE
    testPrice = 1.10050; // Above entry
    result = IsPriceAtReopenLevelSmart_Testable(entryPrice, ORDER_TYPE_BUY_STOP, testPrice);
    AssertFalse("12.4 BUY_STOP.AboveEntry", result,
                StringFormat("BUY_STOP @ %.5f: price %.5f should be FALSE (above entry)",
                            entryPrice, testPrice));

    // 12.5: Price within offset zone = FALSE
    testPrice = 1.09980; // Between entry and (entry - offset)
    result = IsPriceAtReopenLevelSmart_Testable(entryPrice, ORDER_TYPE_BUY_STOP, testPrice);
    AssertFalse("12.5 BUY_STOP.WithinOffsetZone", result,
                StringFormat("BUY_STOP @ %.5f: price %.5f should be FALSE (within offset zone)",
                            entryPrice, testPrice));

    // ═══════════════════════════════════════════════════════════════════
    // TEST 12.6-12.8: SELL_STOP logic (price must be ABOVE entry+offset)
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing SELL_STOP Orders ---");

    // SELL_STOP @ 1.10000 with offset 3 pips:
    // Target price = 1.10000 + 0.00030 = 1.10030
    // Should reopen when price >= 1.10030

    // 12.6: Price well above threshold = TRUE
    testPrice = 1.10050; // Above 1.10030
    result = IsPriceAtReopenLevelSmart_Testable(entryPrice, ORDER_TYPE_SELL_STOP, testPrice);
    AssertTrue("12.6 SELL_STOP.AboveThreshold", result,
               StringFormat("SELL_STOP @ %.5f: price %.5f should be TRUE (above threshold %.5f)",
                           entryPrice, testPrice, entryPrice + offsetPoints));

    // 12.7: Price below entry = FALSE
    testPrice = 1.09950; // Below entry
    result = IsPriceAtReopenLevelSmart_Testable(entryPrice, ORDER_TYPE_SELL_STOP, testPrice);
    AssertFalse("12.7 SELL_STOP.BelowEntry", result,
                StringFormat("SELL_STOP @ %.5f: price %.5f should be FALSE (below entry)",
                            entryPrice, testPrice));

    // 12.8: Price within offset zone = FALSE
    testPrice = 1.10020; // Between entry and (entry + offset)
    result = IsPriceAtReopenLevelSmart_Testable(entryPrice, ORDER_TYPE_SELL_STOP, testPrice);
    AssertFalse("12.8 SELL_STOP.WithinOffsetZone", result,
                StringFormat("SELL_STOP @ %.5f: price %.5f should be FALSE (within offset zone)",
                            entryPrice, testPrice));

    // ═══════════════════════════════════════════════════════════════════
    // TEST 12.9-12.10: Edge cases - exactly at threshold
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Edge Cases (exactly at threshold) ---");

    // 12.9: BUY_STOP - price exactly at threshold (entry - offset)
    testPrice = entryPrice - offsetPoints; // Exactly at threshold
    result = IsPriceAtReopenLevelSmart_Testable(entryPrice, ORDER_TYPE_BUY_STOP, testPrice);
    AssertTrue("12.9 BUY_STOP.ExactlyAtThreshold", result,
               StringFormat("BUY_STOP @ %.5f: price %.5f (exactly at threshold) should be TRUE",
                           entryPrice, testPrice));

    // 12.10: SELL_STOP - price exactly at threshold (entry + offset)
    testPrice = entryPrice + offsetPoints; // Exactly at threshold
    result = IsPriceAtReopenLevelSmart_Testable(entryPrice, ORDER_TYPE_SELL_STOP, testPrice);
    AssertTrue("12.10 SELL_STOP.ExactlyAtThreshold", result,
               StringFormat("SELL_STOP @ %.5f: price %.5f (exactly at threshold) should be TRUE",
                           entryPrice, testPrice));

    // ═══════════════════════════════════════════════════════════════════
    // TEST 12.11-12.12: Variable offset tests
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Variable Offset ---");

    // 12.11: Large offset (10 pips)
    ReopenOffset_Pips_STOP_ORDERS = 10.0;
    offsetPoints = PipsToPoints(10.0);
    testPrice = entryPrice - offsetPoints - 0.00010; // Below threshold
    result = IsPriceAtReopenLevelSmart_Testable(entryPrice, ORDER_TYPE_BUY_STOP, testPrice);
    AssertTrue("12.11 BUY_STOP.LargeOffset", result,
               StringFormat("BUY_STOP with 10 pip offset: price %.5f should be TRUE", testPrice));

    // 12.12: Zero offset (edge case - should still work)
    ReopenOffset_Pips_STOP_ORDERS = 0.0;
    testPrice = entryPrice - 0.00001; // Just below entry
    result = IsPriceAtReopenLevelSmart_Testable(entryPrice, ORDER_TYPE_BUY_STOP, testPrice);
    AssertTrue("12.12 BUY_STOP.ZeroOffset", result,
               StringFormat("BUY_STOP with 0 pip offset: price %.5f (just below entry) should be TRUE", testPrice));

    RestoreInputParameters();
}

//+------------------------------------------------------------------+
//| TEST SUITE 13: CanLevelReopen                                    |
//| Tests the reopen permission logic                                |
//+------------------------------------------------------------------+
void Test_CanLevelReopen() {
    PrintTestHeader("TEST SUITE 13: CanLevelReopen");

    SaveInputParameters();
    ResetGridStatusForTests();

    int testLevel = 0;

    // ═══════════════════════════════════════════════════════════════════
    // TEST 13.1: EnableCyclicReopen = FALSE
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing EnableCyclicReopen ---");

    EnableCyclicReopen = false;
    MaxCyclesPerLevel = 0;
    PauseReopenOnExtreme = false;
    currentATR_Condition = ATR_NORMAL;

    bool result = CanLevelReopen(GRID_A, ZONE_UPPER, testLevel);
    AssertFalse("13.1 EnableCyclicReopen.Disabled", result,
                "Should return FALSE when EnableCyclicReopen is disabled");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 13.2: EnableCyclicReopen = TRUE, all conditions OK
    // ═══════════════════════════════════════════════════════════════════
    EnableCyclicReopen = true;
    result = CanLevelReopen(GRID_A, ZONE_UPPER, testLevel);
    AssertTrue("13.2 EnableCyclicReopen.Enabled", result,
               "Should return TRUE when all conditions are OK");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 13.3-13.5: MaxCyclesPerLevel check
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing MaxCyclesPerLevel ---");

    // 13.3: Max cycles reached
    MaxCyclesPerLevel = 5;
    gridA_Upper_Cycles[testLevel] = 5; // Reached max
    result = CanLevelReopen(GRID_A, ZONE_UPPER, testLevel);
    AssertFalse("13.3 MaxCycles.Reached", result,
                "Should return FALSE when max cycles (5) reached");

    // 13.4: Below max cycles
    gridA_Upper_Cycles[testLevel] = 4; // Below max
    result = CanLevelReopen(GRID_A, ZONE_UPPER, testLevel);
    AssertTrue("13.4 MaxCycles.BelowMax", result,
               "Should return TRUE when cycles (4) < max (5)");

    // 13.5: MaxCyclesPerLevel = 0 (infinite)
    MaxCyclesPerLevel = 0;
    gridA_Upper_Cycles[testLevel] = 999; // Many cycles
    result = CanLevelReopen(GRID_A, ZONE_UPPER, testLevel);
    AssertTrue("13.5 MaxCycles.Infinite", result,
               "Should return TRUE when MaxCyclesPerLevel=0 (infinite)");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 13.6-13.7: Volatility check
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Volatility Check ---");

    MaxCyclesPerLevel = 0;
    gridA_Upper_Cycles[testLevel] = 0;

    // 13.6: PauseReopenOnExtreme=TRUE with ATR_EXTREME
    PauseReopenOnExtreme = true;
    currentATR_Condition = ATR_EXTREME;
    result = CanLevelReopen(GRID_A, ZONE_UPPER, testLevel);
    AssertFalse("13.6 Volatility.Extreme.Pause", result,
                "Should return FALSE when ATR_EXTREME and PauseReopenOnExtreme=true");

    // 13.7: PauseReopenOnExtreme=FALSE with ATR_EXTREME
    PauseReopenOnExtreme = false;
    currentATR_Condition = ATR_EXTREME;
    result = CanLevelReopen(GRID_A, ZONE_UPPER, testLevel);
    AssertTrue("13.7 Volatility.Extreme.NoPause", result,
               "Should return TRUE when ATR_EXTREME but PauseReopenOnExtreme=false");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 13.8: lastClose = 0 (never closed)
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing LastClose ---");

    PauseReopenOnExtreme = false;
    currentATR_Condition = ATR_NORMAL;
    gridA_Upper_LastClose[testLevel] = 0; // Never closed

    result = CanLevelReopen(GRID_A, ZONE_UPPER, testLevel);
    AssertTrue("13.8 LastClose.NeverClosed", result,
               "Should return TRUE when lastClose=0 (never closed)");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 13.9-13.12: Test all Grid/Zone combinations
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing All Grid/Zone Combinations ---");

    EnableCyclicReopen = true;
    MaxCyclesPerLevel = 0;
    PauseReopenOnExtreme = false;
    currentATR_Condition = ATR_NORMAL;

    // Reset all cycles
    gridA_Upper_Cycles[testLevel] = 0;
    gridA_Lower_Cycles[testLevel] = 0;
    gridB_Upper_Cycles[testLevel] = 0;
    gridB_Lower_Cycles[testLevel] = 0;

    result = CanLevelReopen(GRID_A, ZONE_UPPER, testLevel);
    AssertTrue("13.9 GridA.Upper.CanReopen", result, "Grid A Upper should be able to reopen");

    result = CanLevelReopen(GRID_A, ZONE_LOWER, testLevel);
    AssertTrue("13.10 GridA.Lower.CanReopen", result, "Grid A Lower should be able to reopen");

    result = CanLevelReopen(GRID_B, ZONE_UPPER, testLevel);
    AssertTrue("13.11 GridB.Upper.CanReopen", result, "Grid B Upper should be able to reopen");

    result = CanLevelReopen(GRID_B, ZONE_LOWER, testLevel);
    AssertTrue("13.12 GridB.Lower.CanReopen", result, "Grid B Lower should be able to reopen");

    RestoreInputParameters();
    ResetGridStatusForTests();
}

//+------------------------------------------------------------------+
//| TEST SUITE 14: Status Transition Check                           |
//| Tests which statuses allow reopening                             |
//+------------------------------------------------------------------+
void Test_StatusTransitionForReopen() {
    PrintTestHeader("TEST SUITE 14: Status Transition Check");

    SaveInputParameters();
    ResetGridStatusForTests();

    // Setup: Enable reopen, set entry prices
    EnableCyclicReopen = true;
    MaxCyclesPerLevel = 0;
    PauseReopenOnExtreme = false;
    currentATR_Condition = ATR_NORMAL;
    ReopenOffset_Pips_STOP_ORDERS = 3.0;

    int testLevel = 0;
    double testEntryPrice = 1.10000;
    gridA_Upper_EntryPrices[testLevel] = testEntryPrice;
    gridA_Lower_EntryPrices[testLevel] = testEntryPrice - 0.00200; // Below entry

    // Note: ShouldReopenGridAUpper/Lower also checks IsPriceAtReopenLevelSmart
    // which depends on live price. We test the status check logic here.

    Print("\n--- Testing Status Check Logic ---");

    // ═══════════════════════════════════════════════════════════════════
    // Test status check conditions (manual validation)
    // ═══════════════════════════════════════════════════════════════════

    // 14.1: ORDER_NONE - cannot reopen
    gridA_Upper_Status[testLevel] = ORDER_NONE;
    bool statusAllowsReopen = (gridA_Upper_Status[testLevel] == ORDER_CLOSED_TP ||
                               gridA_Upper_Status[testLevel] == ORDER_CLOSED_SL ||
                               gridA_Upper_Status[testLevel] == ORDER_CANCELLED);
    AssertFalse("14.1 Status.ORDER_NONE", statusAllowsReopen,
                "ORDER_NONE should NOT allow reopen");

    // 14.2: ORDER_PENDING - cannot reopen
    gridA_Upper_Status[testLevel] = ORDER_PENDING;
    statusAllowsReopen = (gridA_Upper_Status[testLevel] == ORDER_CLOSED_TP ||
                          gridA_Upper_Status[testLevel] == ORDER_CLOSED_SL ||
                          gridA_Upper_Status[testLevel] == ORDER_CANCELLED);
    AssertFalse("14.2 Status.ORDER_PENDING", statusAllowsReopen,
                "ORDER_PENDING should NOT allow reopen");

    // 14.3: ORDER_FILLED - cannot reopen
    gridA_Upper_Status[testLevel] = ORDER_FILLED;
    statusAllowsReopen = (gridA_Upper_Status[testLevel] == ORDER_CLOSED_TP ||
                          gridA_Upper_Status[testLevel] == ORDER_CLOSED_SL ||
                          gridA_Upper_Status[testLevel] == ORDER_CANCELLED);
    AssertFalse("14.3 Status.ORDER_FILLED", statusAllowsReopen,
                "ORDER_FILLED should NOT allow reopen");

    // 14.4: ORDER_CLOSED (generic) - cannot reopen
    gridA_Upper_Status[testLevel] = ORDER_CLOSED;
    statusAllowsReopen = (gridA_Upper_Status[testLevel] == ORDER_CLOSED_TP ||
                          gridA_Upper_Status[testLevel] == ORDER_CLOSED_SL ||
                          gridA_Upper_Status[testLevel] == ORDER_CANCELLED);
    AssertFalse("14.4 Status.ORDER_CLOSED", statusAllowsReopen,
                "ORDER_CLOSED (generic) should NOT allow reopen");

    // 14.5: ORDER_CLOSED_TP - CAN reopen
    gridA_Upper_Status[testLevel] = ORDER_CLOSED_TP;
    statusAllowsReopen = (gridA_Upper_Status[testLevel] == ORDER_CLOSED_TP ||
                          gridA_Upper_Status[testLevel] == ORDER_CLOSED_SL ||
                          gridA_Upper_Status[testLevel] == ORDER_CANCELLED);
    AssertTrue("14.5 Status.ORDER_CLOSED_TP", statusAllowsReopen,
               "ORDER_CLOSED_TP should allow reopen");

    // 14.6: ORDER_CLOSED_SL - CAN reopen
    gridA_Upper_Status[testLevel] = ORDER_CLOSED_SL;
    statusAllowsReopen = (gridA_Upper_Status[testLevel] == ORDER_CLOSED_TP ||
                          gridA_Upper_Status[testLevel] == ORDER_CLOSED_SL ||
                          gridA_Upper_Status[testLevel] == ORDER_CANCELLED);
    AssertTrue("14.6 Status.ORDER_CLOSED_SL", statusAllowsReopen,
               "ORDER_CLOSED_SL should allow reopen");

    // 14.7: ORDER_CANCELLED - CAN reopen
    gridA_Upper_Status[testLevel] = ORDER_CANCELLED;
    statusAllowsReopen = (gridA_Upper_Status[testLevel] == ORDER_CLOSED_TP ||
                          gridA_Upper_Status[testLevel] == ORDER_CLOSED_SL ||
                          gridA_Upper_Status[testLevel] == ORDER_CANCELLED);
    AssertTrue("14.7 Status.ORDER_CANCELLED", statusAllowsReopen,
               "ORDER_CANCELLED should allow reopen");

    // 14.8: ORDER_ERROR - cannot reopen
    gridA_Upper_Status[testLevel] = ORDER_ERROR;
    statusAllowsReopen = (gridA_Upper_Status[testLevel] == ORDER_CLOSED_TP ||
                          gridA_Upper_Status[testLevel] == ORDER_CLOSED_SL ||
                          gridA_Upper_Status[testLevel] == ORDER_CANCELLED);
    AssertFalse("14.8 Status.ORDER_ERROR", statusAllowsReopen,
                "ORDER_ERROR should NOT allow reopen");

    RestoreInputParameters();
    ResetGridStatusForTests();
}

//+------------------------------------------------------------------+
//| TEST SUITE 15: Entry Price Preservation                          |
//| Tests that entry prices remain unchanged after reopen            |
//+------------------------------------------------------------------+
void Test_EntryPricePreservation() {
    PrintTestHeader("TEST SUITE 15: Entry Price Preservation");

    ResetGridStatusForTests();

    double spacing = 20.0;
    double testEntryPoint = 1.10000;
    entryPoint = testEntryPoint;

    // Setup entry prices for all grids
    Print("\n--- Setting up Entry Prices ---");

    for(int level = 0; level < 5; level++) {
        // Grid A Upper (BUY STOP - above entry)
        double priceAUpper = testEntryPoint + PipsToPoints(spacing/2.0 + spacing * level);
        gridA_Upper_EntryPrices[level] = priceAUpper;

        // Grid A Lower (BUY LIMIT - below entry)
        double priceALower = testEntryPoint - PipsToPoints(spacing/2.0 + spacing * level);
        gridA_Lower_EntryPrices[level] = priceALower;

        // Grid B Upper (SELL LIMIT - above entry)
        gridB_Upper_EntryPrices[level] = priceAUpper;

        // Grid B Lower (SELL STOP - below entry)
        gridB_Lower_EntryPrices[level] = priceALower;
    }

    // Store original prices
    double originalPrices_A_Upper[5];
    double originalPrices_A_Lower[5];
    double originalPrices_B_Upper[5];
    double originalPrices_B_Lower[5];

    for(int i = 0; i < 5; i++) {
        originalPrices_A_Upper[i] = gridA_Upper_EntryPrices[i];
        originalPrices_A_Lower[i] = gridA_Lower_EntryPrices[i];
        originalPrices_B_Upper[i] = gridB_Upper_EntryPrices[i];
        originalPrices_B_Lower[i] = gridB_Lower_EntryPrices[i];
    }

    // Simulate status changes (as if orders were opened and closed)
    Print("\n--- Simulating Order Lifecycle ---");
    for(int level = 0; level < 5; level++) {
        // Simulate: ORDER_NONE -> ORDER_PENDING -> ORDER_FILLED -> ORDER_CLOSED_TP
        gridA_Upper_Status[level] = ORDER_CLOSED_TP;
        gridA_Lower_Status[level] = ORDER_CLOSED_TP;
        gridB_Upper_Status[level] = ORDER_CLOSED_TP;
        gridB_Lower_Status[level] = ORDER_CLOSED_TP;

        // Simulate reopen cycle (status reset)
        gridA_Upper_Status[level] = ORDER_NONE;
        gridA_Lower_Status[level] = ORDER_NONE;
        gridB_Upper_Status[level] = ORDER_NONE;
        gridB_Lower_Status[level] = ORDER_NONE;
    }

    // Verify entry prices are unchanged
    Print("\n--- Verifying Entry Price Preservation ---");

    for(int level = 0; level < 5; level++) {
        // 15.1-15.4: Grid A Upper
        AssertEquals(StringFormat("15.1 GridA.Upper.L%d.Preserved", level),
                    gridA_Upper_EntryPrices[level], originalPrices_A_Upper[level], 0.00001,
                    "Entry price should be unchanged");

        // Grid A Lower
        AssertEquals(StringFormat("15.2 GridA.Lower.L%d.Preserved", level),
                    gridA_Lower_EntryPrices[level], originalPrices_A_Lower[level], 0.00001,
                    "Entry price should be unchanged");

        // Grid B Upper
        AssertEquals(StringFormat("15.3 GridB.Upper.L%d.Preserved", level),
                    gridB_Upper_EntryPrices[level], originalPrices_B_Upper[level], 0.00001,
                    "Entry price should be unchanged");

        // Grid B Lower
        AssertEquals(StringFormat("15.4 GridB.Lower.L%d.Preserved", level),
                    gridB_Lower_EntryPrices[level], originalPrices_B_Lower[level], 0.00001,
                    "Entry price should be unchanged");
    }

    // 15.5: Multiple reopen cycles - prices still unchanged
    Print("\n--- Testing Multiple Reopen Cycles ---");
    for(int cycle = 0; cycle < 3; cycle++) {
        for(int level = 0; level < 5; level++) {
            // Simulate another cycle
            gridA_Upper_Status[level] = ORDER_CLOSED_TP;
            gridA_Upper_Status[level] = ORDER_NONE;
        }
    }

    // Verify prices after multiple cycles
    bool allPreserved = true;
    for(int level = 0; level < 5; level++) {
        if(MathAbs(gridA_Upper_EntryPrices[level] - originalPrices_A_Upper[level]) > 0.00001) {
            allPreserved = false;
            break;
        }
    }
    AssertTrue("15.5 MultipleReopens.PricesPreserved", allPreserved,
               "Entry prices should remain unchanged after multiple reopen cycles");

    ResetGridStatusForTests();
}

//+------------------------------------------------------------------+
//| TEST SUITE 16: Cycle Count Increment                             |
//| Tests the IncrementCycleCount function                           |
//+------------------------------------------------------------------+
void Test_CycleCountIncrement() {
    PrintTestHeader("TEST SUITE 16: Cycle Count Increment");

    ResetGridStatusForTests();

    int testLevel = 0;

    // ═══════════════════════════════════════════════════════════════════
    // TEST 16.1-16.4: Individual grid/zone increments
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Individual Increments ---");

    // 16.1: Grid A Upper
    AssertEqualsInt("16.1a GridA.Upper.Initial", gridA_Upper_Cycles[testLevel], 0,
                    "Initial cycles should be 0");
    IncrementCycleCount(GRID_A, ZONE_UPPER, testLevel);
    AssertEqualsInt("16.1b GridA.Upper.AfterIncrement", gridA_Upper_Cycles[testLevel], 1,
                    "After increment should be 1");

    // 16.2: Grid A Lower
    AssertEqualsInt("16.2a GridA.Lower.Initial", gridA_Lower_Cycles[testLevel], 0,
                    "Initial cycles should be 0");
    IncrementCycleCount(GRID_A, ZONE_LOWER, testLevel);
    AssertEqualsInt("16.2b GridA.Lower.AfterIncrement", gridA_Lower_Cycles[testLevel], 1,
                    "After increment should be 1");

    // 16.3: Grid B Upper
    AssertEqualsInt("16.3a GridB.Upper.Initial", gridB_Upper_Cycles[testLevel], 0,
                    "Initial cycles should be 0");
    IncrementCycleCount(GRID_B, ZONE_UPPER, testLevel);
    AssertEqualsInt("16.3b GridB.Upper.AfterIncrement", gridB_Upper_Cycles[testLevel], 1,
                    "After increment should be 1");

    // 16.4: Grid B Lower
    AssertEqualsInt("16.4a GridB.Lower.Initial", gridB_Lower_Cycles[testLevel], 0,
                    "Initial cycles should be 0");
    IncrementCycleCount(GRID_B, ZONE_LOWER, testLevel);
    AssertEqualsInt("16.4b GridB.Lower.AfterIncrement", gridB_Lower_Cycles[testLevel], 1,
                    "After increment should be 1");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 16.5: Multiple increments accumulate
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Multiple Increments ---");

    ResetGridStatusForTests();

    for(int i = 0; i < 10; i++) {
        IncrementCycleCount(GRID_A, ZONE_UPPER, testLevel);
    }
    AssertEqualsInt("16.5 GridA.Upper.MultipleIncrements", gridA_Upper_Cycles[testLevel], 10,
                    "After 10 increments should be 10");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 16.6: Different levels are isolated
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Level Isolation ---");

    ResetGridStatusForTests();

    // Increment only level 0
    for(int i = 0; i < 5; i++) {
        IncrementCycleCount(GRID_A, ZONE_UPPER, 0);
    }

    // Increment level 1 separately
    for(int i = 0; i < 3; i++) {
        IncrementCycleCount(GRID_A, ZONE_UPPER, 1);
    }

    // Level 2 untouched

    AssertEqualsInt("16.6a Level0.Isolated", gridA_Upper_Cycles[0], 5,
                    "Level 0 should have 5 cycles");
    AssertEqualsInt("16.6b Level1.Isolated", gridA_Upper_Cycles[1], 3,
                    "Level 1 should have 3 cycles");
    AssertEqualsInt("16.6c Level2.Untouched", gridA_Upper_Cycles[2], 0,
                    "Level 2 should have 0 cycles (untouched)");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 16.7: Grid/Zone isolation
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Grid/Zone Isolation ---");

    ResetGridStatusForTests();

    IncrementCycleCount(GRID_A, ZONE_UPPER, 0);
    IncrementCycleCount(GRID_A, ZONE_UPPER, 0);
    IncrementCycleCount(GRID_A, ZONE_LOWER, 0);
    IncrementCycleCount(GRID_B, ZONE_UPPER, 0);

    AssertEqualsInt("16.7a GridA.Upper.Isolated", gridA_Upper_Cycles[0], 2,
                    "Grid A Upper should have 2 cycles");
    AssertEqualsInt("16.7b GridA.Lower.Isolated", gridA_Lower_Cycles[0], 1,
                    "Grid A Lower should have 1 cycle");
    AssertEqualsInt("16.7c GridB.Upper.Isolated", gridB_Upper_Cycles[0], 1,
                    "Grid B Upper should have 1 cycle");
    AssertEqualsInt("16.7d GridB.Lower.Untouched", gridB_Lower_Cycles[0], 0,
                    "Grid B Lower should have 0 cycles (untouched)");

    ResetGridStatusForTests();
}

//+------------------------------------------------------------------+
//| TEST SUITE 17: Integration - Complete Reopen Flow                |
//| Tests the full reopen workflow                                   |
//+------------------------------------------------------------------+
void Test_CompleteReopenFlow() {
    PrintTestHeader("TEST SUITE 17: Complete Reopen Flow Integration");

    SaveInputParameters();
    ResetGridStatusForTests();

    // Setup environment
    EnableCyclicReopen = true;
    MaxCyclesPerLevel = 0;
    PauseReopenOnExtreme = false;
    currentATR_Condition = ATR_NORMAL;
    ReopenOffset_Pips_STOP_ORDERS = 3.0;

    int testLevel = 0;
    double testEntryPrice = 1.10000;

    gridA_Upper_EntryPrices[testLevel] = testEntryPrice;
    gridA_Lower_EntryPrices[testLevel] = testEntryPrice - 0.00200;

    // ═══════════════════════════════════════════════════════════════════
    // TEST 17.1: Full flow - ORDER_CLOSED_TP scenario
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Full Flow: Close TP -> Reopen Ready ---");

    // Initial state
    gridA_Upper_Status[testLevel] = ORDER_NONE;
    gridA_Upper_Cycles[testLevel] = 0;

    // Simulate: Order placed
    gridA_Upper_Status[testLevel] = ORDER_PENDING;
    AssertTrue("17.1a InitialState.Pending", gridA_Upper_Status[testLevel] == ORDER_PENDING,
               "Order should be PENDING after placement");

    // Simulate: Order filled
    gridA_Upper_Status[testLevel] = ORDER_FILLED;
    AssertTrue("17.1b State.Filled", gridA_Upper_Status[testLevel] == ORDER_FILLED,
               "Order should be FILLED");

    // Simulate: Order closed with TP
    gridA_Upper_Status[testLevel] = ORDER_CLOSED_TP;
    gridA_Upper_LastClose[testLevel] = TimeCurrent();
    AssertTrue("17.1c State.ClosedTP", gridA_Upper_Status[testLevel] == ORDER_CLOSED_TP,
               "Order should be CLOSED_TP");

    // Check if can reopen
    bool canReopen = CanLevelReopen(GRID_A, ZONE_UPPER, testLevel);
    AssertTrue("17.1d CanReopen.AfterTP", canReopen,
               "Should be able to reopen after TP close");

    // Simulate reopen (status reset + cycle increment)
    gridA_Upper_Status[testLevel] = ORDER_NONE;
    IncrementCycleCount(GRID_A, ZONE_UPPER, testLevel);

    AssertEqualsInt("17.1e CycleCount.AfterReopen", gridA_Upper_Cycles[testLevel], 1,
                    "Cycle count should be 1 after first reopen");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 17.2: Full flow - ORDER_CLOSED_SL scenario
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Full Flow: Close SL -> Reopen Ready ---");

    // Simulate another cycle
    gridA_Upper_Status[testLevel] = ORDER_PENDING;
    gridA_Upper_Status[testLevel] = ORDER_FILLED;
    gridA_Upper_Status[testLevel] = ORDER_CLOSED_SL;
    gridA_Upper_LastClose[testLevel] = TimeCurrent();

    canReopen = CanLevelReopen(GRID_A, ZONE_UPPER, testLevel);
    AssertTrue("17.2a CanReopen.AfterSL", canReopen,
               "Should be able to reopen after SL close");

    // Simulate reopen
    gridA_Upper_Status[testLevel] = ORDER_NONE;
    IncrementCycleCount(GRID_A, ZONE_UPPER, testLevel);

    AssertEqualsInt("17.2b CycleCount.AfterSecondReopen", gridA_Upper_Cycles[testLevel], 2,
                    "Cycle count should be 2 after second reopen");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 17.3: Full flow - ORDER_CANCELLED scenario
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Full Flow: Cancel -> Reopen Ready ---");

    gridA_Upper_Status[testLevel] = ORDER_PENDING;
    gridA_Upper_Status[testLevel] = ORDER_CANCELLED;
    gridA_Upper_LastClose[testLevel] = TimeCurrent();

    canReopen = CanLevelReopen(GRID_A, ZONE_UPPER, testLevel);
    AssertTrue("17.3a CanReopen.AfterCancel", canReopen,
               "Should be able to reopen after cancellation");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 17.4: Reopen blocked by max cycles
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Reopen Blocked by Max Cycles ---");

    MaxCyclesPerLevel = 3;
    gridA_Upper_Cycles[testLevel] = 3; // Reached max
    gridA_Upper_Status[testLevel] = ORDER_CLOSED_TP;

    canReopen = CanLevelReopen(GRID_A, ZONE_UPPER, testLevel);
    AssertFalse("17.4 ReopenBlocked.MaxCycles", canReopen,
                "Should NOT be able to reopen when max cycles reached");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 17.5: Multiple levels reopen independently
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Multiple Levels Independence ---");

    ResetGridStatusForTests();
    MaxCyclesPerLevel = 0;

    // Setup multiple levels
    for(int level = 0; level < 5; level++) {
        gridA_Upper_EntryPrices[level] = testEntryPrice + PipsToPoints(10 * level);
        gridA_Upper_Status[level] = ORDER_CLOSED_TP;
        gridA_Upper_LastClose[level] = TimeCurrent();
    }

    // Check all can reopen
    bool allCanReopen = true;
    for(int level = 0; level < 5; level++) {
        if(!CanLevelReopen(GRID_A, ZONE_UPPER, level)) {
            allCanReopen = false;
            break;
        }
    }
    AssertTrue("17.5 MultipleLevels.AllCanReopen", allCanReopen,
               "All levels should be able to reopen independently");

    RestoreInputParameters();
    ResetGridStatusForTests();
}

//+------------------------------------------------------------------+
//| TEST SUITE 18: Order Type Assignment for Reopen                  |
//| Tests GetGridOrderType function                                  |
//+------------------------------------------------------------------+
void Test_OrderTypeForReopen() {
    PrintTestHeader("TEST SUITE 18: Order Type Assignment for Reopen");

    // ═══════════════════════════════════════════════════════════════════
    // Grid A = SEMPRE BUY (Long Bias)
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Grid A Order Types ---");

    // 18.1: Grid A Upper = BUY STOP (sopra entry, aspetta breakout)
    ENUM_ORDER_TYPE orderType = GetGridOrderType(GRID_A, ZONE_UPPER);
    AssertTrue("18.1 GridA.Upper.BUY_STOP", orderType == ORDER_TYPE_BUY_STOP,
               StringFormat("Grid A Upper should be BUY_STOP, got %s", EnumToString(orderType)));

    // 18.2: Grid A Lower = BUY LIMIT (sotto entry, aspetta pullback)
    orderType = GetGridOrderType(GRID_A, ZONE_LOWER);
    AssertTrue("18.2 GridA.Lower.BUY_LIMIT", orderType == ORDER_TYPE_BUY_LIMIT,
               StringFormat("Grid A Lower should be BUY_LIMIT, got %s", EnumToString(orderType)));

    // ═══════════════════════════════════════════════════════════════════
    // Grid B = SEMPRE SELL (Short Bias)
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Grid B Order Types ---");

    // 18.3: Grid B Upper = SELL LIMIT (sopra entry, aspetta test resistenza)
    orderType = GetGridOrderType(GRID_B, ZONE_UPPER);
    AssertTrue("18.3 GridB.Upper.SELL_LIMIT", orderType == ORDER_TYPE_SELL_LIMIT,
               StringFormat("Grid B Upper should be SELL_LIMIT, got %s", EnumToString(orderType)));

    // 18.4: Grid B Lower = SELL STOP (sotto entry, aspetta breakdown)
    orderType = GetGridOrderType(GRID_B, ZONE_LOWER);
    AssertTrue("18.4 GridB.Lower.SELL_STOP", orderType == ORDER_TYPE_SELL_STOP,
               StringFormat("Grid B Lower should be SELL_STOP, got %s", EnumToString(orderType)));

    // ═══════════════════════════════════════════════════════════════════
    // Reopen Behavior Implications
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Reopen Behavior by Order Type ---");

    // LIMIT orders = immediate reopen (broker protects)
    // STOP orders = wait for price offset

    // 18.5: Grid A Upper (BUY_STOP) - should NOT reopen immediately
    orderType = GetGridOrderType(GRID_A, ZONE_UPPER);
    bool isStopOrder = (orderType == ORDER_TYPE_BUY_STOP || orderType == ORDER_TYPE_SELL_STOP);
    AssertTrue("18.5 GridA.Upper.IsSTOP", isStopOrder,
               "Grid A Upper should be STOP order (needs offset check)");

    // 18.6: Grid A Lower (BUY_LIMIT) - CAN reopen immediately
    orderType = GetGridOrderType(GRID_A, ZONE_LOWER);
    bool isLimitOrder = (orderType == ORDER_TYPE_BUY_LIMIT || orderType == ORDER_TYPE_SELL_LIMIT);
    AssertTrue("18.6 GridA.Lower.IsLIMIT", isLimitOrder,
               "Grid A Lower should be LIMIT order (immediate reopen)");

    // 18.7: Grid B Upper (SELL_LIMIT) - CAN reopen immediately
    orderType = GetGridOrderType(GRID_B, ZONE_UPPER);
    isLimitOrder = (orderType == ORDER_TYPE_BUY_LIMIT || orderType == ORDER_TYPE_SELL_LIMIT);
    AssertTrue("18.7 GridB.Upper.IsLIMIT", isLimitOrder,
               "Grid B Upper should be LIMIT order (immediate reopen)");

    // 18.8: Grid B Lower (SELL_STOP) - should NOT reopen immediately
    orderType = GetGridOrderType(GRID_B, ZONE_LOWER);
    isStopOrder = (orderType == ORDER_TYPE_BUY_STOP || orderType == ORDER_TYPE_SELL_STOP);
    AssertTrue("18.8 GridB.Lower.IsSTOP", isStopOrder,
               "Grid B Lower should be STOP order (needs offset check)");
}

//+------------------------------------------------------------------+
//| TEST SUITE 19: RecordCloseTime Function                          |
//| Tests the close time recording for levels                        |
//+------------------------------------------------------------------+
void Test_RecordCloseTime() {
    PrintTestHeader("TEST SUITE 19: RecordCloseTime Function");

    ResetGridStatusForTests();

    int testLevel = 0;
    datetime beforeTime = TimeCurrent();

    // Small delay to ensure time difference
    Sleep(100);

    // ═══════════════════════════════════════════════════════════════════
    // TEST 19.1-19.4: Record close time for all grid/zone combinations
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing RecordCloseTime for All Grid/Zones ---");

    // 19.1: Grid A Upper
    RecordCloseTime(GRID_A, ZONE_UPPER, testLevel);
    AssertTrue("19.1 GridA.Upper.CloseTimeRecorded",
               gridA_Upper_LastClose[testLevel] >= beforeTime,
               "Close time should be recorded for Grid A Upper");

    // 19.2: Grid A Lower
    RecordCloseTime(GRID_A, ZONE_LOWER, testLevel);
    AssertTrue("19.2 GridA.Lower.CloseTimeRecorded",
               gridA_Lower_LastClose[testLevel] >= beforeTime,
               "Close time should be recorded for Grid A Lower");

    // 19.3: Grid B Upper
    RecordCloseTime(GRID_B, ZONE_UPPER, testLevel);
    AssertTrue("19.3 GridB.Upper.CloseTimeRecorded",
               gridB_Upper_LastClose[testLevel] >= beforeTime,
               "Close time should be recorded for Grid B Upper");

    // 19.4: Grid B Lower
    RecordCloseTime(GRID_B, ZONE_LOWER, testLevel);
    AssertTrue("19.4 GridB.Lower.CloseTimeRecorded",
               gridB_Lower_LastClose[testLevel] >= beforeTime,
               "Close time should be recorded for Grid B Lower");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 19.5: Level isolation
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Level Isolation for CloseTime ---");

    ResetGridStatusForTests();

    // Record close time only for level 1
    RecordCloseTime(GRID_A, ZONE_UPPER, 1);

    AssertTrue("19.5a Level0.Untouched", gridA_Upper_LastClose[0] == 0,
               "Level 0 close time should remain 0");
    AssertTrue("19.5b Level1.Recorded", gridA_Upper_LastClose[1] > 0,
               "Level 1 close time should be recorded");
    AssertTrue("19.5c Level2.Untouched", gridA_Upper_LastClose[2] == 0,
               "Level 2 close time should remain 0");

    ResetGridStatusForTests();
}

//+------------------------------------------------------------------+
//| TEST SUITE 20: Edge Cases and Boundary Conditions                |
//| Tests edge cases in the reopen system                            |
//+------------------------------------------------------------------+
void Test_EdgeCases() {
    PrintTestHeader("TEST SUITE 20: Edge Cases and Boundary Conditions");

    SaveInputParameters();
    ResetGridStatusForTests();

    // ═══════════════════════════════════════════════════════════════════
    // TEST 20.1: Maximum level index
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Maximum Level Index ---");

    EnableCyclicReopen = true;
    MaxCyclesPerLevel = 0;
    PauseReopenOnExtreme = false;
    currentATR_Condition = ATR_NORMAL;

    int maxValidLevel = MAX_GRID_LEVELS - 1;

    // Set status for max level
    gridA_Upper_Status[maxValidLevel] = ORDER_CLOSED_TP;
    gridA_Upper_Cycles[maxValidLevel] = 0;

    bool canReopen = CanLevelReopen(GRID_A, ZONE_UPPER, maxValidLevel);
    AssertTrue("20.1 MaxLevelIndex.CanReopen", canReopen,
               StringFormat("Level %d (max) should be able to reopen", maxValidLevel));

    // ═══════════════════════════════════════════════════════════════════
    // TEST 20.2: Minimum level index (0)
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Minimum Level Index ---");

    gridA_Upper_Status[0] = ORDER_CLOSED_TP;
    gridA_Upper_Cycles[0] = 0;

    canReopen = CanLevelReopen(GRID_A, ZONE_UPPER, 0);
    AssertTrue("20.2 MinLevelIndex.CanReopen", canReopen,
               "Level 0 (min) should be able to reopen");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 20.3: Very small offset (0.1 pips)
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Very Small Offset ---");

    ReopenOffset_Pips_STOP_ORDERS = 0.1;
    double entryPrice = 1.10000;
    double offsetPoints = PipsToPoints(0.1);
    double testPrice = entryPrice - offsetPoints - 0.00001;

    bool result = IsPriceAtReopenLevelSmart_Testable(entryPrice, ORDER_TYPE_BUY_STOP, testPrice);
    AssertTrue("20.3 SmallOffset.BUY_STOP", result,
               StringFormat("BUY_STOP with 0.1 pip offset should work (price %.5f)", testPrice));

    // ═══════════════════════════════════════════════════════════════════
    // TEST 20.4: Very large offset (100 pips)
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Very Large Offset ---");

    ReopenOffset_Pips_STOP_ORDERS = 100.0;
    offsetPoints = PipsToPoints(100.0);
    testPrice = entryPrice - offsetPoints - 0.00010;

    result = IsPriceAtReopenLevelSmart_Testable(entryPrice, ORDER_TYPE_BUY_STOP, testPrice);
    AssertTrue("20.4 LargeOffset.BUY_STOP", result,
               StringFormat("BUY_STOP with 100 pip offset should work (price %.5f)", testPrice));

    // ═══════════════════════════════════════════════════════════════════
    // TEST 20.5: Cycle count at max int boundary
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing High Cycle Count ---");

    MaxCyclesPerLevel = 0; // Infinite
    gridA_Upper_Cycles[0] = INT_MAX - 1;
    gridA_Upper_Status[0] = ORDER_CLOSED_TP;

    canReopen = CanLevelReopen(GRID_A, ZONE_UPPER, 0);
    AssertTrue("20.5 HighCycleCount.CanReopen", canReopen,
               "Should be able to reopen even with very high cycle count when MaxCycles=0");

    // ═══════════════════════════════════════════════════════════════════
    // TEST 20.6: Invalid price (0 or negative)
    // ═══════════════════════════════════════════════════════════════════
    Print("\n--- Testing Invalid Prices ---");

    ReopenOffset_Pips_STOP_ORDERS = 3.0;

    result = IsPriceAtReopenLevelSmart_Testable(1.10000, ORDER_TYPE_BUY_STOP, 0);
    AssertFalse("20.6a InvalidPrice.Zero", result,
                "Should return FALSE for zero current price");

    result = IsPriceAtReopenLevelSmart_Testable(1.10000, ORDER_TYPE_BUY_STOP, -1.0);
    AssertFalse("20.6b InvalidPrice.Negative", result,
                "Should return FALSE for negative current price");

    RestoreInputParameters();
    ResetGridStatusForTests();
}

//+------------------------------------------------------------------+
//| Script Start                                                     |
//+------------------------------------------------------------------+
void OnStart() {
    Print("\n");
    Print("╔═══════════════════════════════════════════════════════════════╗");
    Print("║          SUGAMARA - ORDER REOPEN UNIT TESTS                   ║");
    Print("║                     Version 1.00                              ║");
    Print("╚═══════════════════════════════════════════════════════════════╝");
    Print("");

    // Setup environment
    SetupTestEnvironment();
    Print("");

    // Run all test suites
    Test_IsPriceAtReopenLevelSmart();
    Print("");

    Test_CanLevelReopen();
    Print("");

    Test_StatusTransitionForReopen();
    Print("");

    Test_EntryPricePreservation();
    Print("");

    Test_CycleCountIncrement();
    Print("");

    Test_CompleteReopenFlow();
    Print("");

    Test_OrderTypeForReopen();
    Print("");

    Test_RecordCloseTime();
    Print("");

    Test_EdgeCases();
    Print("");

    // Print summary
    PrintTestSummary();
}
//+------------------------------------------------------------------+
